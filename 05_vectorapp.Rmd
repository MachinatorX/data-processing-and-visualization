## Vectorization & Apply

```{r vasetup, include=FALSE, eval=TRUE, cache=FALSE}
knitr::opts_chunk$set(eval=FALSE)
```


### Boolean Indexing

Assume <span class="objclass">x</span> is a vector of numbers. How would we create an index representing any value greater than 2?

```{r boolindex, eval=T}
x = c(-1, 2, 10, -5)
idx = x > 2
idx
x[idx]
```

<span class="objclass">Logicals</span> are objects with values of `TRUE` or `FALSE`, like the <span class="objclass">idx</span> variable above.  While sometimes we want to deal with the logical object as an end, it is extremely commonly used as an index in data processing. Note that how we don't have to create an explicit index object first (though often you should), as R indexing is ridiculously flexible.  Here are more examples, not necessarily recommended, but just to demonstrate the flexibility of Boolean indexing.

```{r flexindex}
x[x > 2]
x[x != 3]
x[ifelse(x > 2 & x !=10, TRUE, FALSE)]
x[{y = idx; y}]
x[resid(lm(y ~ x)) > 0]
```

### Vectorized operations

Boolean indexing allows us to take <span class="emph">vectorized</span> approaches to dealing with data. Consider the following unfortunately coded loop:

```{r loop}
for (i in 1:nrow(mydf)) {
  check = mydf$x[i] > 2
  if (check==TRUE) {
    mydf$y[i] = 'Yes'
  } 
  else {
    mydf$y[i] = 'No'
  }
}
```

Compare[^ifelse]:

```{r boolnoloop}
mydf$y = 'No'
mydf$y[mydf$x > 2] = 'Yes'
```

This gets us the same thing, and would be much faster than the looped approach. Boolean indexing is an example of a vectorized operation.  The whole vector is considered, rather than each element individually.  The result is that any preprocessing is done once rather than the `n` iterations of the loop.  In R, this will  always faster.

Example: Log all values in a matrix.

```{r vecmatrixop}
mymatrix_log = log(mymatrix)
```

This is way faster than looping over elements, rows or columns. Here we'll let the <span class="func">apply</span> function stand in for our loop, logging the elements of each column.

```{r loopvsvec, eval=T}
mymatrix = matrix(runif(100), 10, 10)
identical(apply(mymatrix, 2, log), log(mymatrix))

library(microbenchmark)
microbenchmark(apply(mymatrix, 2, log),
               log(mymatrix))
```


Many vectorized functions already exist in R.  They are often written in C, Fortran etc., and so even faster.  Not all programming languages lean toward vectorized operations, and may not see much speed gain from it.  In R however, you'll want to prefer it.  Even without, it's cleaner/clearer code, another reason to use the approach.
  

### Apply functions

A family of functions comes with R that allows for a succinct way of looping. Common functions in this family include:

- <span class="func">apply</span>
    - arrays, matrices, data.frames
- <span class="func">lapply</span>, <span class="func">sapply</span>, <span class="func">vapply</span>
    - lists, data.frames, vectors
- <span class="func">tapply</span>
    - grouped operations (table apply)
- <span class="func">mapply</span>
    - multivariate version of sapply
- <span class="func">replicate</span>
    - similar to sapply
    
As an example we'll consider standardizing variables, i.e. taking a set of numbers, subtracting the mean, and dividing by the standard deviation.  This results in a variable with mean of 0 and standard deviation of 1.  Let's start with a loop approach.

```{r loopvsapply1, eval=FALSE}
for (i in 1:ncol(mydf)){
  x = mydf[,i]
  for (j in 1:length(x)){
    x[j] = (x[j] - mean(x))/sd(x)
  }
}
```

The above would be a really bad way to use R. It goes over each column individually, then over each value of the column. 

Conversely, <span class="func">apply</span> will take a matrix or data frame, and apply a function over the margin, row or column, you want to loop over.  The first argument is the data you're considering, the margin is the second argument (1 for rows, 2 for columns), and the function you want to apply to those rows is the third argument.  The following example is much cleaner compared to the loop, and now you'd have a function you can use elsewhere if needed.

```{r loopvsapply2, eval=F}
stdize <- function(x) {
  (x-mean(x)) / sd(x)
}

apply(mydf, 2, stdize)   # 1 for rows, 2 for columnwise application
```

Many of the other apply functions work similarly, taking an object and a function to do the work on the object (possibly implicit), possibly with other arguments if necessary.

#### Timings

The previous demonstrates how to use apply. However, there is a <span class="func">scale</span> function in base R that uses a more vectorized approach under the hood. The following demonstrates various approaches to standardizing the columns of the matrix, even using a parallelized approach. As you'll see, the base R function requires very little code and beats the others.

```{r timings, echo=T}
mymat = matrix(rnorm(100000), ncol=1000)

stdize <- function(x) {
  (x-mean(x)) / sd(x)
}

doubleloop = function() {
  for (i in 1:ncol(mymat)) {
    x = mymat[, i]
    for (j in 1:length(x)) {
      x[j] = (x[j] - mean(x)) / sd(x)
    }
  }
}


singleloop = function() {
  for (i in 1:ncol(mymat)) {
    x = mymat[, i]
    x = (x - mean(x)) / sd(x)
  }
}


library(parallel)
cl = makeCluster(8)
clusterExport(cl, c('stdize', 'mymat'))
doParallel::registerDoParallel(cl)

test = microbenchmark::microbenchmark(doubleloop=doubleloop(),
                                      singleloop=singleloop(), 
                                      apply=apply(mymat, 2, stdize), 
                                      parApply=parApply(cl, mymat, 2, stdize),
                                      vectorized=scale(mymat), times=25)
stopCluster(cl)
test
```
```{r vectorization_timings, echo=FALSE, eval=TRUE, cache=FALSE}
load('data/vectorization.RData'); library(microbenchmark); test
```

    
#### Apply functions

It is important to be familiar with and regularly use the apply family for efficient data processing. A summary of benefits includes:
  
- Cleaner/simpler code
- Environment kept clear of unnecessary objects
- Potentially more reproducible
    - more likely to use generalizable functions
- Might be faster
- Parallelizable
    
Note that apply functions are <span class="emph">NOT</span> necessarily faster than explicit loops.

- single loop over columns was as fast as apply
- <span class="func">replicate</span> and <span class="func">mapply</span> are especially slow

However, the apply family can ALWAYS can *potentially* be faster than standard R loops do to para parallelization.  With base R's <span class="pack">parallel</span> package, there are parallel versions of the apply family, e.g.<span class="func">parApply</span>, <span class="func">parLapply</span> etc.

Apply functions and similar approaches should be a part of your regular R experience.  We'll talk about other options that may have even more benefits, but you need to know the basics in order to use those.  



<div class='note'>
I use R every day, and very rarely use explicit loops.  Note that there is no speed difference for a <span class="func">for</span> loop vs. using <span class="func">while</span>.  And if you must use an explicit loop, create an empty object of the dimension/form you need, and then fill it in via the loop.  This will be notably faster.

I pretty much never use an explicit double loop, as a little more thinking about the problem will usually provide a more efficient path to solving the problem.

<img class='img-note' src="img/R.ico" style="display:block; margin: 0 auto;"> 
</div>




### **Vector/Apply Exercises**


#### Exercise 1

With the following <span class="objclass">matrix</span>, use <span class="func">apply</span> and the <span class="func">sum</span> function to get row or column sums.  

```{r vectorapp_ex1, echo=1}
x = matrix(1:9, 3, 3)
apply()
```

#### Exercise 2

With the following <span class="objclass">list</span>, use <span class="func">lapply</span> and <span class="func">sapply</span> and the <span class="func">sum</span> function to get sums for the elements.  There is no margin to specify with on a list, so just supply the list and the sum function.  

```{r vectorapp_ex2, echo=1}
x = list(1:3, 4:6, 7:9)
lapply()
sapply()
```

<span class="func">sapply</span> is actually just a wrapper for <span class="func">lapply</span>.  If you supply the argument `simplified=F`, it is identical. Otherwise, it attempts to return a vector or matrix.


[^ifelse]: For those familiar with <span class="func">ifelse</span>, that would be applicable, but is not the point of the example.