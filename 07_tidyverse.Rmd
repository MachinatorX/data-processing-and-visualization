## Tidyverse


```{r tvsetup, include=FALSE, eval=TRUE, cache=FALSE}
knitr::opts_chunk$set(echo = T, eval=T)
```

### What is the tidyverse?

The tidyverse consists of a few key packages-

- <span class="pack">ggplot2</span>: data visualization
- <span class="pack">dplyr</span>: data manipulation
- <span class="pack">tidyr</span>: data tidying
- <span class="pack">readr</span>: data import
- <span class="pack">purrr</span>: functional programming, e.g. alternate approaches to apply
- <span class="pack">tibble</span>: tibbles, a modern re-imagining of data frames

And of course the <span class="pack">tidyverse</span> package which will load all of the above.

See also: <span class="pack">lubridate</span>, <span class="pack">rvest</span>, <span class="pack">stringr</span> and others in the 'hadleyverse'.

### What is tidy?

<span class="emph">Tidy data</span> refers to data arranged in a way that makes data processing, analysis, and visualization simpler.

In a tidy data set: 

- Each variable must have its own column.
- Each observation must have its own row.
- Each value must have its own cell.

Think *long* before *wide*.


### dplyr

<span class="pack">dplyr</span> provides a grammar of data manipulation (like <span class="pack">ggplot2</span> does for visualization).

It is the next iteration of <span class="pack">plyr</span>, but there is no longer any need for plyr really.

It's focused on tools for working with data frames.

- Over 100 functions

It has three main goals:

- Make the most important data manipulation tasks easier.
- Do them faster.
- Use the same interface to work with data frames, data tables or database.


Some key operations:


- <span class="func">select</span>: grab columns
    - select helpers: <span class="func">one\_of</span>, <span class="func">starts\_with</span>, <span class="func">num_range</span> etc.
- <span class="func">filter</span>/<span class="func">slice</span>: grab rows
- <span class="func">group_by</span>: grouped operations
- <span class="func">mutate</span>/<span class="func">transmute</span>: create new variables
- <span class="func">summarize</span>: summarize/aggregate
- <span class="func">do</span>: arbitrary operations

Various join/merge functions:

- <span class="func">inner_join</span>, <span class="func">left_join</span> etc.

Little things like:

- <span class="func">n</span>, <span class="func">n\_distinct</span>, <span class="func">nth</span>, <span class="func">n\_groups</span>, <span class="func">count</span>, <span class="func">recode</span>, <span class="func">between</span>

No need to quote variable names.


#### An example

Let's say we want to select from our data the following variables:

  - Start with the **ID** variable
  - The variables **X1:X10**, which are not all together, and there are many more *X* columns
  - The variables **var1** and **var2**, which are the only *var* variables in the data
  - Any variable that starts with **XYZ**
    
How might we go about this?

##### Some base R approaches

Tedious, or multiple objects just to get the columns you want.

```{r baseRexample1, eval=FALSE}
# numeric indexes; not conducive to readibility or reproducibility
newData = oldData[,c(1,2,3,4, etc.)]

# explicitly by name; fine if only a handful; not pretty
newData = oldData[,c('ID','X1', 'X2', etc.)]

# two step with grep; regex difficult to read/understand
cols = c('ID', paste0('X', 1:10), 'var1', 'var2', grep(colnames(oldData), '^XYZ', value=T))
newData = oldData[,cols]

# or via subset
newData = subset(oldData, select = cols)
```


##### More

What if you also want observations where **Z** is **Yes**, Q is **No**, and only the observations with the top 50 values of **var2**, ordered by **var1** (descending)?

```{r baseRexample2, eval=FALSE}
# three operations and overwriting or creating new objects if we want clarity
newData = newData[oldData$Z == 'Yes' & oldData$Q == 'No',]
newData = newData[order(newData$var2, decreasing=T)[1:50],]
newData = newData[order(newData$var1, decreasing=T),]
```

And this is for fairly straightforward operations.


##### The dplyr way

```{r pipeExample, eval=FALSE}
newData = oldData %>% 
  filter(Z == 'Yes', Q == 'No') %>% 
  select(num_range('X', 1:10), contains('var'), starts_with('XYZ')) %>% 
  top_n(n=50, var2) %>% 
  arrange(desc(var1))
```



#### An alternative


<span class="pack">dplyr</span> and piping is an *alternative*. You can do all this sort of stuff with base R, for example, with <span class="func">with</span>, <span class="func">within</span>, <span class="func">subset</span>, <span class="func">transform</span>, etc.

Even though the initial base R approach depicted is fairly concise, it still can potentially be: 

- noisier
- less legible
- less amenable to additional data changes
- requires esoteric knowledge (e.g. regular expressions)
- often requires creation of new objects (even if we just want to explore)
- often slower, possibly greatly


### Running example

The following data was scraped initially scraped from the web as follows.  However you can just load it into your workspace.

```{r basketballDataScrape, eval=FALSE}
library(rvest); 
url = "http://www.basketball-reference.com/leagues/NBA_2017_totals.html"
bball = read_html(url) %>% 
  html_nodes("#totals_stats") %>% 
  html_table %>% 
  data.frame 
save(bball, file='data/bball.RData')
```

When initially downloaded, the data is all character strings.  We'll fix this later.

```{r mutateAt0}
load('data/bball.RData')
glimpse(bball[,1:5])
```


### Selecting Columns

Often you do not need the entire data set. While this is easily handled in base R (as shown earlier), it can be more clear to use <span class="func">select</span> in <span class='pack'>dplyr</span>.  Now we won't have to create separate objects, use quotes or $, etc.

```{r select1, cache=TRUE}
bball %>% 
  select(Player, Tm, Pos) %>% 
  head
```

What if we want to drop some variables?

```{r select2, cache=TRUE}
bball %>%     
  select(-Player, -Tm, -Pos)  %>% 
  head
```

#### Helper functions

Sometimes, we have a lot of variables to select, and if they have a common naming scheme, this can be very easy.

```{r select3, cache=TRUE}
bball %>% 
  select(Player, contains("3P"), ends_with("RB")) %>% 
  arrange(desc(TRB)) %>% 
  head
```

I probably don't even need to explain what's being done above, and this is the power of the tidyverse way.  Here are the list of <span class="emph">helper functions</span> to be aware of:

- <span class="func">starts_with</span>: starts with a prefix
- <span class="func">ends_with</span>: ends with a prefix
- <span class="func">contains</span>: contains a literal string
- <span class="func">matches</span>: matches a regular expression
- <span class="func">num_range</span>: a numerical range like x01, x02, x03.
- <span class="func">one_of</span>: variables in character vector.
- <span class="func">everything</span>: all variables.

### Filtering Rows

There are repeated header rows in this data[^headers], so we need to drop them.  This is also why everything was character string when we first read it in, because having any character strings makes everything a character string.  Filtering by rows requires the basic indexing knowledge we talked about before, especially boolean indexing. In the following, `Rk`, or rank, is really just a row id, but if it equals 'Rk', we know it's a header row, so we'll drop it.

```{r filter0}
bball = bball %>% 
  filter(Rk != "Rk")
```

- <span class='func'>filter</span> returns rows with matching conditions.
- <span class='func'>slice</span> allows for a numeric indexing approach.

Say we want too look at forwards (SF or PF) over the age of 35.  The following will do this, and since some players play on multiple teams, we'll want only the unique information on the variables of interest. The function <span class="func">distinct</span> allows us to do this.


```{r filter1}
bball %>% 
  filter(Age > 35, Pos == "SF" | Pos == "PF") %>% 
  distinct(Player, Pos, Age)              
```

or the first 10 rows...

```{r filter2}
bball %>% 
  slice(1:10)
```

This can be done with things that are created on the fly...

```{r uniteFilterArrange}
bball %>% 
  unite("posTeam", Pos, Tm) %>%         # create a new variable
  filter(posTeam == "PF_SAS") %>%       # use it for filtering
  arrange(desc(Age))                    # order 
```

### Generating New Data

One of the most common data processing tasks is generating new variables. The function <span class='func'>mutate</span> takes a vector and returns one of the same dimension.  In addition, there is <span class="func">mutate_at</span>, <span class="func">mutate_if</span>, and <span class="func">mutate_all</span> to help with specific scenarios.


To demonstrate, we'll use <span class='func'>mutate_at</span> to make appropriate columns numeric, i.e. everything except `Player`, `Pos`, and ` Tm`.  It takes two inputs, variables and functions to apply.

```{r mutateAt, cache=TRUE}
bball = bball %>% 
  mutate_at(vars(-Player, -Pos, -Tm), funs(as.numeric))   

glimpse(bball[,1:7])
```

The following demonstrates how we can create composites of existing variables.

```{r mutate, cache=TRUE}
bball = bball %>% 
  mutate(trueShooting = PTS / (2 * (FGA + (.44 * FTA))),
         effectiveFG = (FG + (.5 * X3P)) / FGA, 
         shootingDif = trueShooting - FG.)

summary(select(bball, shootingDif))  # select and others don't have to be piped to use
```


### Grouping and Summarizing Data

A very common task is to look at group-based statistics, and we can use <span class='func'>group_by</span> and <span class="func">summarize</span> to help us in this regard[^summarise].  Base R has things like <span class="func">aggregate</span> and <span class="func">tapply</span>, but they should *never* be used, and this approach is much more straightforward.

For this, I'm going to start putting together several things we've demonstrated thus far

```{r groupby, eval=TRUE, cache=TRUE}
bball %>%   
  mutate(trueShooting = PTS / (2 * (FGA + (.44 * FTA))),
         effectiveFG = (FG + (.5 * X3P)) / FGA, 
         shootingDif = trueShooting - FG.) %>%  
  select(Player, Tm, Pos, MP, trueShooting, effectiveFG, PTS) %>% 
  group_by(Pos) %>%                                                 # can group by more than one variable
  summarize(meanTrueShooting = mean(trueShooting, na.rm = TRUE))    # potentially any function can work
```

Use <span class="func">do</span> on grouped data to go further.  The following will group data by position, then get the correlation between field-goal percentage and free-throw shooting percentage.  For some reason, one individual was labeled as 'PF-C'.

```{r do, cache=T}
bball %>% 
  mutate(Pos = if_else(Pos=='PF-C', 'C', Pos)) %>% 
  group_by(Pos) %>%     
  do(FgFt_Corr=cor(.$FG., .$FT., use='complete')) %>% 
  unnest(FgFt_Corr)
```

As a reminder, data frames are lists. As such, anything can go into the 'columns', even the results of analyses.


```{r do2}
library(nycflights13)
carriers = group_by(flights, carrier)
group_size(carriers)

mods = do(carriers, model = lm(arr_delay ~ dep_time, data = .)) # reminder that data frames are lists
mods %>% 
  summarize(rsq = summary(model)$r.squared) %>% 
  head
```

### Merging Data


### tidyr

Tidyr can be thought of as a more special subset of dplyr functionality.  Two primary functions for manipulating data you'll want ot be familiar with are:

- <span class="func">gather</span>: wide to long
- <span class="func">spread</span>: long to wide

Other useful functions include:

- <span class="func">unite</span>: paste together multiple columns into one
- <span class="func">separate</span>: complement of unite
- <span class="func">unnest</span>: unnest 'list columns'

#### Example

```{r gather_spread, eval=T}
library(tidyr)
stocks <- data.frame( time = as.Date('2009-01-01') + 0:9,
                      X = rnorm(10, 0, 1),
                      Y = rnorm(10, 0, 2),
                      Z = rnorm(10, 0, 4) )
stocks %>% head
stocks %>% 
  gather(stock, price, -time) %>% 
  head
```

Note that the latter is an example of <span class="emph">tidy data</span> while the former is not.

Separate player into first and last names based on the space

```{r tidyrSpread, cache=TRUE}
bball %>% 
  separate(Player, into=c('firstName', 'lastName'), sep=' ') %>% 
  select(1:5) %>% 
  head
```


### Purrr

Purr allows you to take the <span class="func">apply</span> family approach to the tidyverse.

Consider Exercise 2 from the Vectorization/Apply section.  We'll use the <span class="func">map</span> function to map the <span class="func">sum</span> function to each element in the list, the the same way we would with <span class="func">lapply</span>.

```{r purr example}
x = list(1:3, 4:6, 7:9)
x %>% 
  map(sum)
```



### Personal Opinion

The <span class="pack">dplyr</span> grammar is clear for a lot of standard data processing tasks, and some not so common.

Extremely useful for data exploration and visualization.

- No need to create/overwrite existing objects
- Can overwrite columns as they are created
- Makes it easy to look at anything, and do otherwise tedious data checks

Drawbacks:

- Not as fast as <span class="pack">data.table</span> or even some base R approaches for many things[^multidplyr]
- The *mindset* can make for unnecessary complication
    - e.g. There is no need to pipe to create one new variable
- Some approaches are not very intuitive
    
    



### **dplyr Exercises**

#### Exercise 0

Install and load the <span class="pack">dplyr</span> <span class="pack">ggplot2movies</span> packages. Look at the help file for the `movies` data set, which contains data from IMDB.


```{r, eval=FALSE}
install.packages('ggplot2movies')
library(ggplot2movies)
```


#### Exercise 1

Using the movies data set, perform each of the following actions separately.

##### Exercise 1a

Use <span class="func">mutate</span> to create a centered version of the rating variable.  A centered variable is one whose mean has been subtracted from it. The process will take the following form:

```{r ex1a_1, eval=FALSE}
data %>% 
  mutate(newvar = '?')
```

```{r ex1a_2, echo=FALSE}
movies %>% 
  mutate(ratingCen = rating - mean(rating)) 
```

##### Exercise 1b

Use <span class="func">filter</span> to create a new data frame that has only movies from the years 2000 and beyond. Use the greater than or equal operator `>=`.

```{r ex1b, echo=FALSE}
movies %>% 
  filter(year >= 2000) 
```

##### Exercise 1c

Use <span class="func">select</span> to create a new data frame that only has the title, year, budget, length, rating and votes variables.  There are at least 3 ways to do this.

```{r ex1c, echo=FALSE}
movies %>% 
  select(title, year, budget, length, rating, votes) 
movies %>% 
  select(1:6)
movies %>% 
  select(-num_range('r',1:10), -mpaa, -starts_with('A'), -Comedy, -starts_with('D'), -Romance, -Short)
```



#### Exercise 2

Use <span class="func">group_by</span> to group the data by year, and <span class="func">summarize</span> to create a new variable that is the average budget. The <span class="func">summarize</span> function works just like <span class="func">mutate</span> in this case.
Use the <span class="func">mean</span> function to get the average, but you'll also need to use the argument `na.rm = TRUE` within it because the earliest years have no budget recorded.


```{r ex2, echo=FALSE}
movies %>% 
  group_by(year) %>% 
  summarise(AvgBudget=mean(budget, na.rm=T)) %>% 
  tail
```


#### Exercise 3

Now put it all together in one set of piped operations. 

- Filter movies released *after* 1990
- select the same variables as before but also the `mpaa`, `Action`, and `Drama` variables
- group by `mpaa` *and* `Action` *or* `Drama`
- get the average rating


```{r ex3, echo=FALSE}
movies %>%
  filter(year>=1990) %>% 
  select(title, year, budget, length, rating, votes, mpaa, Action, Drama) %>% 
  group_by(mpaa, Drama) %>% 
  summarise(AvgRating = mean(rating))
```


[^headers]: You may be thinking- 'its 2017 and why on earth would anyone do that?!'.  Peruse most sports websites and you'll see that fundamental web design basics escape them.  See also, financial sites.

[^summarise]: As Hadley Wickham is from New Zealand, and his examples use <span class="func">summarise</span>, you'll probably see it about as much as you do the other spelling.

[^multidplyr]: There is <span class="pack">multidplyr</span>, but it doesn't appear to have been updated since well before <span class="pack">dplyr</span> itself underwent major changes.